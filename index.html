<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>ãµã¨ã‚“ç©ºæ°—èª­ã¿ãƒãƒˆãƒ« v1.0</title>
  <style>
    :root {
      --bg1:#0d1b2a;
      --bg2:#1b263b;
      --ui:#e0e1dd;
      --accent:#ffd166;
      --good:#80ed99;
      --warn:#ff6b6b;
    }
    * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
    html, body {
      margin:0; height:100%; overflow:hidden;
      background:linear-gradient(180deg,var(--bg1),var(--bg2));
      color:var(--ui);
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
      touch-action: none;
    }
    #app {
      position: fixed; inset:0;
      display:grid;
      grid-template-rows: auto 1fr auto;
      gap: 8px;
      padding: calc(env(safe-area-inset-top) + 8px) 10px calc(env(safe-area-inset-bottom) + 10px);
      touch-action:none;
    }
    .topbar {
      display:flex; align-items:center; justify-content:space-between; gap:8px;
      font-weight:600; font-size:14px;
    }
    .pill { background:rgba(255,255,255,.12); border-radius:999px; padding:6px 10px; white-space:nowrap; }
    canvas {
      width:100%; height:100%;
      border-radius:14px;
      background: radial-gradient(120% 90% at 50% 20%, #274060 0%, #111927 80%);
      display:block;
      box-shadow:0 10px 30px rgba(0,0,0,.35);
    }
    .controls {
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:8px;
    }
    button {
      border:none; border-radius:14px; color:#fff;
      font-size: clamp(14px, 2.9vw, 18px);
      font-weight:700; min-height:56px;
      touch-action: manipulation;
    }
    #btnPull { background:#f25f5c; }
    #btnWait { background:#247ba0; }
    #btnReturn { background:#70c1b3; }
    .subcontrols {
      margin-top:8px;
      display:grid; grid-template-columns: repeat(4, minmax(0, 1fr));
      gap:8px;
    }
    .subcontrols button { min-height:42px; background:rgba(255,255,255,.15); }
    #overlay {
      position:absolute; inset:0;
      display:grid; place-items:center;
      pointer-events:none;
    }
    .card {
      width:min(92vw, 560px);
      background:rgba(0,0,0,.45);
      border:1px solid rgba(255,255,255,.2);
      border-radius:16px;
      padding:16px;
      backdrop-filter: blur(6px);
      text-align:center;
      pointer-events:auto;
    }
    .card h1{ margin:0 0 8px; font-size:clamp(20px, 4vw, 32px); }
    .card p{ margin:6px 0; line-height:1.45; }
    .small { opacity:.86; font-size:12px; }
    .event {
      position:absolute; left:50%; top:14%; transform:translateX(-50%);
      background:rgba(0,0,0,.52); border:1px solid rgba(255,255,255,.2);
      border-radius:12px; padding:8px 12px; text-align:center;
      min-width:min(90vw,360px);
      pointer-events:none;
    }
    .event strong { color:var(--accent); }
    .hidden { display:none !important; }
  </style>
</head>
<body>
  <div id="app">
    <div class="topbar">
      <div class="pill" id="seedLabel">seed: -</div>
      <div class="pill" id="timeLabel">20.0s</div>
      <div class="pill" id="statusLabel">title</div>
    </div>
    <div style="position:relative; min-height:260px;">
      <canvas id="gameCanvas"></canvas>
      <div id="overlay"></div>
      <div id="eventBox" class="event hidden"></div>
    </div>
    <div>
      <div class="controls">
        <button id="btnPull">å¼•ã</button>
        <button id="btnWait">å¾…ã¤</button>
        <button id="btnReturn">æˆ»ã™</button>
      </div>
      <div class="subcontrols">
        <button id="btnStart">ã‚¹ã‚¿ãƒ¼ãƒˆ</button>
        <button id="btnRestart">ã‚„ã‚Šç›´ã—</button>
        <button id="btnMute">ğŸ”Š éŸ³ON</button>
        <button id="btnRandSeed">ãƒ©ãƒ³ãƒ€ãƒ seed</button>
      </div>
      <div class="subcontrols">
        <button id="btnCopySeed">seed URLã‚³ãƒ”ãƒ¼</button>
        <button id="btnShareX">Xã§å…±æœ‰</button>
        <button id="btnCard">çµæœã‚«ãƒ¼ãƒ‰ä¿å­˜</button>
        <button id="btnToday">ä»Šæ—¥ã®seed</button>
      </div>
    </div>
  </div>
<script>
(() => {
  'use strict';

  // ===== èª¿æ•´ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ =====
  const TUNE = {
    gameSec: 20,
    dtMax: 0.05,
    pullBoundaryPerSec: 0.17,
    waitBoundaryDecayPerSec: 0.03,
    returnBoundaryPerSec: 0.21,
    reclaimBase: 0.05,
    reclaimTwitchBoost: 0.12,
    disturbanceDecay: 1.2,
    pullDisturbancePerSec: 0.78,
    waitSleepRecoverPerSec: 0.22,
    returnSleepRecoverPerSec: 0.46,
    disturbanceToSleepDrop: 0.24,
    kDisturbanceToQ: 6.1,
    penaltyPow: 1.7,
    eventCount: 3,
    eventShowSec: 2.2,
  };

  // ===== ä¹±æ•°ï¼ˆseedå›ºå®šï¼‰ =====
  function hashStringToInt(str) {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  }
  function mulberry32(a) {
    return function() {
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ (t >>> 15), t | 1);
      t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
      return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
    };
  }
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a,b,t) => a + (b-a)*t;

  // ===== ãƒ‡ãƒ¼ã‚¿ =====
  const TITLES = [
    { tier:'S', title:'ç¾½æ¯›ç¥ã®åŒèª¿è€…', line:'ã¬ãã‚‚ã‚Šã¨å„ªã—ã•ã€ã©ã¡ã‚‰ã‚‚æº€ç‚¹ã€‚' },
    { tier:'S', title:'å¤œæ˜ã‘ã®æ°—é…ã‚Šç‹', line:'å¥ªã„ã™ããšã€è­²ã‚Šã™ããšã€‚å®Œç’§ã€‚' },
    { tier:'S', title:'å¸ƒå›£å¢ƒç•Œã®è©©äºº', line:'å¢ƒç•Œç·šã«ç¾å­¦ãŒå®¿ã£ã¦ã„ã‚‹ã€‚' },
    { tier:'S', title:'ç„¡éŸ³å¯å®¤ãƒã‚¹ã‚¿ãƒ¼', line:'ç›¸æ‰‹ã‚’èµ·ã“ã•ãšæš–ã‹ãçœ ã‚ŒãŸã€‚' },
    { tier:'S', title:'ã¬ãã¬ãå¤–äº¤å®˜', line:'äº¤æ¸‰ãªãå¹³å’Œã‚’å®Ÿç¾ã—ãŸå¤œã€‚' },
    { tier:'S', title:'ç¡çœ å®ˆè­·é¨å£«', line:'æœã®æ©Ÿå«Œã¾ã§å®ˆã‚‹å„ªã—ã„åæ‰‹ã€‚' },
    { tier:'A', title:'å¸ƒå›£ã‚·ã‚§ã‚¢ä¸Šæ‰‹', line:'ã»ã¼ç†æƒ³ã®é…åˆ†ã€ã‚ã¨ä¸€æ­©ã§ä¼èª¬ã€‚' },
    { tier:'A', title:'å¤œæ›´ã‘ã®ãƒãƒ©ãƒ³ã‚µãƒ¼', line:'ç©ºæ°—ã‚’èª­ã¿ãªãŒã‚‰æš–ã‚’ç¢ºä¿ã€‚' },
    { tier:'A', title:'å¯ç›¸ãƒˆãƒ¬ãƒ¼ãƒ€ãƒ¼', line:'ç´°ã‹ã„èª­ã¿åˆã„ãŒå…‰ã£ãŸã€‚' },
    { tier:'A', title:'ã¬ãã‚‚ã‚Šæœ€é©åŒ–ä¿‚', line:'ã¡ã‚ƒã‚“ã¨æ¸©ã‹ãã€ã¡ã‚ƒã‚“ã¨é™ã‹ã€‚' },
    { tier:'A', title:'é™ã‹ãªå‹ã¡ç­‹ã®äºº', line:'æ´¾æ‰‹ã•ã¯ãªã„ãŒçµæœã¯è‰¯ã„ã€‚' },
    { tier:'A', title:'æ·±å¤œã®è‰¯è­˜æ´¾', line:'æœã®ä¼šè©±ãŒã‚„ã•ã—ããªã‚‹ãƒ—ãƒ¬ã‚¤ã€‚' },
    { tier:'B', title:'ãµã¤ã†ã«å„ªç§€', line:'ç„¡é›£ã«ã†ã¾ãã‚„ã‚ŒãŸå¤œã€‚' },
    { tier:'B', title:'ã‚„ã‚„æ§ãˆã‚ã‚¹ãƒˆãƒ©ã‚¤ã‚«ãƒ¼', line:'æ”»ã‚ã‚’æŠ‘ãˆã¦å®‰å®šã‚’å–ã£ãŸã€‚' },
    { tier:'B', title:'åŠåˆ†åäºº', line:'èª­ã¿ã¯å½“ãŸã‚‹ãŒã€å°‘ã—æ¬²å¼µã‚Šã€‚' },
    { tier:'B', title:'å¤œã®èª¿åœè€…', line:'ãŸã¾ã®å¼•ãã™ãã¯ã”æ„›å¬Œã€‚' },
    { tier:'B', title:'ã“ãŸã¤å¿ƒã®æŒã¡ä¸»', line:'ã¬ãã‚‚ã‚Šé‡è¦–ã§ã‚‚é…æ…®ã¯ã‚ã‚‹ã€‚' },
    { tier:'B', title:'åŠç¬¬ç‚¹ãƒ‘ãƒ¼ãƒˆãƒŠãƒ¼', line:'æœã®ç©ºæ°—ã¯ã ã„ãŸã„å¹³å’Œã€‚' },
    { tier:'C', title:'ã¡ã‚‡ã„å¼•ã£ã±ã‚ŠéšŠ', line:'æ‚ªããªã„ã‘ã©ã€ç›¸æ‰‹ãŒå°‘ã—çœ ãã†ã€‚' },
    { tier:'C', title:'æ·±å¤œã®è‡ªå·±éƒ½åˆæ´¾', line:'æš–ã‹ã•ã¯ç¢ºä¿ã€é…æ…®ã¯æ¬¡å›ã¸ã€‚' },
    { tier:'C', title:'å¯è¿”ã‚Šèª˜ç™ºå£«', line:'ãƒ”ã‚¯â€¦ã‚’è¦‹é€ƒã—ãŒã¡ã ã£ãŸã€‚' },
    { tier:'C', title:'å¢ƒç•Œç·šã‚ªãƒ¼ãƒãƒ¼ãƒ©ãƒ³', line:'ã‚ã¨å°‘ã—ã®æˆ‘æ…¢ã§Aã ã£ãŸã€‚' },
    { tier:'C', title:'æƒœã—ã„ãµã¨ã‚“é‹ã³', line:'æŠ€è¡“ã¯ã‚ã‚‹ã€‚ç©ºæ°—èª­ã¿ãŒèª²é¡Œã€‚' },
    { tier:'C', title:'æœã®è¨€ã„è¨³æº–å‚™ä¸­', line:'ã€Œå¯’ã‹ã£ãŸã‚“ã ã‚‚ã‚“ã€ã¯é€šã˜ã‚‹ã‹ã€‚' },
    { tier:'D', title:'ãµã¨ã‚“ç‹¬å è¦‹ç¿’ã„', line:'å‹ã£ãŸæ°—ã¯ã™ã‚‹ãŒæœãŒæ€–ã„ã€‚' },
    { tier:'D', title:'ç¡çœ ã‚¯ãƒ©ãƒƒã‚·ãƒ£ãƒ¼äºˆå‚™è»', line:'ç›¸æ‰‹ã®ZzzãŒç´°ã™ããŸã€‚' },
    { tier:'D', title:'å¤œã®å¼·å¼•ãƒ‰ãƒ©ã‚¤ãƒãƒ¼', line:'æ€¥ãƒãƒ³ãƒ‰ãƒ«å¤šã‚ã®æ“ä½œã ã£ãŸã€‚' },
    { tier:'D', title:'å°ç‰©éŸ³ãƒ¡ãƒ¼ã‚«ãƒ¼', line:'ã‚¬ã‚µãƒƒâ€¦ã§ç©ºæ°—ãŒå‡ã£ãŸã€‚' },
    { tier:'D', title:'å¯å®¤ãƒˆãƒ©ãƒ–ãƒ«ä¿‚', line:'æ˜æ—¥ã¯ã‚³ãƒ¼ãƒ’ãƒ¼ã‚’æ·¹ã‚Œã‚ˆã†ã€‚' },
    { tier:'D', title:'å¸ƒå›£ä¼šè­°ãƒ»è¦æ‹›é›†', line:'æ¬¡å›ã¯ã€Œæˆ»ã™ã€ã‚’æ€ã„å‡ºã—ã¦ã€‚' },
  ];

  const EVENTS = [
    { id:'cat', name:'ã­ã“ãŒä¹—ã£ã¦ããŸ', hint:'é‡ã¿ã§å¸ƒå›£ãŒãšã‚Œã‚‹â€¦', durSec:4.5, effects:{ reclaim:+0.05, sleep:+0.05, twitch:+0.08, disturbance:+0.04 } },
    { id:'cold', name:'å†·æ°—ãŒã—ã®ã³ã“ã‚€', hint:'ã¤ã„å¼•ããŸããªã‚‹å¯’ã•', durSec:5.0, effects:{ reclaim:-0.03, sleep:-0.06, twitch:+0.06, disturbance:+0.08 } },
    { id:'sniffle', name:'ç›¸æ‰‹ãŒã‚€ã«ã‚ƒâ€¦', hint:'æµ…ã„çœ ã‚Šã€åˆºæ¿€ã«æ³¨æ„', durSec:4.0, effects:{ reclaim:+0.02, sleep:-0.09, twitch:+0.20, disturbance:+0.10 } },
    { id:'heater', name:'æš–æˆ¿ãŒã¡ã‚‡ã†ã©è‰¯ã„', hint:'å¾…ã¤ã¨å›å¾©ã—ã‚„ã™ã„', durSec:4.2, effects:{ reclaim:-0.02, sleep:+0.09, twitch:-0.10, disturbance:-0.04 } },
    { id:'roll', name:'å¯è¿”ã‚Šã®äºˆå…†', hint:'ãƒ”ã‚¯â€¦ä»Šå¼•ãã®ã¯å±é™º', durSec:3.8, effects:{ reclaim:+0.06, sleep:-0.03, twitch:+0.28, disturbance:+0.02 } },
    { id:'dream', name:'ã„ã„å¤¢ã‚’è¦‹ã¦ã„ã‚‹', hint:'é™ã‹ã«ã™ã‚Œã°æ·±ãçœ ã‚‹', durSec:4.4, effects:{ reclaim:-0.03, sleep:+0.12, twitch:-0.14, disturbance:-0.05 } },
    { id:'ping', name:'é€šçŸ¥éŸ³ãŒé ãã§é³´ã‚‹', hint:'å°ã•ãªç‰©éŸ³ãŒåˆºã•ã‚‹å¤œ', durSec:3.6, effects:{ reclaim:+0.01, sleep:-0.04, twitch:+0.15, disturbance:+0.12 } },
    { id:'stretch', name:'ç›¸æ‰‹ãŒã®ã³ã‚’ã—ãŸ', hint:'å¸ƒå›£ã®ä½ç½®ãŒãµã‚‰ã¤ã', durSec:4.8, effects:{ reclaim:+0.09, sleep:+0.01, twitch:+0.12, disturbance:+0.02 } },
    { id:'calm', name:'é›¨éŸ³ãŒå¿ƒåœ°ã„ã„', hint:'æˆ»ã™ã¨è©•ä¾¡ãŒä¼¸ã³ã‚‹ã‹ã‚‚', durSec:4.6, effects:{ reclaim:-0.04, sleep:+0.10, twitch:-0.08, disturbance:-0.03 } },
    { id:'itch', name:'å¸ƒå›£ãŒã¡ã‚‡ã£ã¨ã‚‚ãã‚‚ã', hint:'å°ã•ãèª¿æ•´ã™ã‚‹ã®ãŒå‰', durSec:3.9, effects:{ reclaim:+0.04, sleep:-0.02, twitch:+0.09, disturbance:+0.06 } },
  ];

  // ===== DOM =====
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const eventBox = document.getElementById('eventBox');
  const seedLabel = document.getElementById('seedLabel');
  const timeLabel = document.getElementById('timeLabel');
  const statusLabel = document.getElementById('statusLabel');

  const btnPull = document.getElementById('btnPull');
  const btnWait = document.getElementById('btnWait');
  const btnReturn = document.getElementById('btnReturn');
  const btnStart = document.getElementById('btnStart');
  const btnRestart = document.getElementById('btnRestart');
  const btnMute = document.getElementById('btnMute');
  const btnRandSeed = document.getElementById('btnRandSeed');
  const btnCopySeed = document.getElementById('btnCopySeed');
  const btnShareX = document.getElementById('btnShareX');
  const btnCard = document.getElementById('btnCard');
  const btnToday = document.getElementById('btnToday');

  // ===== çŠ¶æ…‹ =====
  const defaultSeed = getTodaySeed();
  const url = new URL(location.href);
  let seed = (url.searchParams.get('seed') || defaultSeed).replace(/[^0-9A-Za-z_-]/g,'').slice(0,24) || defaultSeed;
  let rng = mulberry32(hashStringToInt(seed));

  const state = {
    mode: 'title',
    timeLeft: TUNE.gameSec,
    boundary: 0.5,
    sleepDepth: 0.76,
    disturbance: 0.0,
    disturbanceTotal: 0.0,
    reclaim: TUNE.reclaimBase,
    twitch: 0.15,
    input: 'wait',
    eventTimeline: [],
    activeEvent: null,
    eventDisplayTimer: 0,
    eventIndex: 0,
    score: null,
    titlePick: null,
    floaty: [],
    animTime: 0,
  };

  // ===== Audio =====
  let audioCtx = null;
  let muted = false;
  function ensureAudio() {
    if (muted) return null;
    if (!audioCtx) {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === 'suspended') audioCtx.resume();
    return audioCtx;
  }
  function beep(type='sine', f=320, d=0.08, vol=0.03) {
    if (muted) return;
    const ac = ensureAudio();
    if (!ac) return;
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type;
    o.frequency.value = f;
    g.gain.value = 0;
    g.gain.linearRampToValueAtTime(vol, ac.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + d);
    o.connect(g); g.connect(ac.destination);
    o.start(); o.stop(ac.currentTime + d + 0.01);
  }

  function getTodaySeed() {
    const d = new Date();
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,'0');
    const day = String(d.getDate()).padStart(2,'0');
    return `${y}${m}${day}`;
  }

  function setSeed(newSeed) {
    seed = newSeed;
    rng = mulberry32(hashStringToInt(seed));
    const u = new URL(location.href);
    u.searchParams.set('seed', seed);
    history.replaceState(null, '', u.toString());
    seedLabel.textContent = `seed: ${seed}`;
  }

  function makeRandomSeed() {
    const t = Date.now().toString(36).toUpperCase();
    return `${getTodaySeed()}-${t.slice(-4)}`;
  }

  function shuffleBySeed(arr, seedText) {
    const r = mulberry32(hashStringToInt(seedText));
    const out = arr.slice();
    for (let i = out.length - 1; i > 0; i--) {
      const j = Math.floor(r() * (i + 1));
      [out[i], out[j]] = [out[j], out[i]];
    }
    return out;
  }

  function prepareEvents() {
    const picks = shuffleBySeed(EVENTS, `${seed}-events`).slice(0, TUNE.eventCount);
    const spacing = TUNE.gameSec / (TUNE.eventCount + 1);
    state.eventTimeline = picks.map((ev, i) => ({
      ...ev,
      triggerAt: spacing * (i + 1)
    }));
    state.eventIndex = 0;
    state.activeEvent = null;
    state.eventDisplayTimer = 0;
  }

  function resetRun() {
    rng = mulberry32(hashStringToInt(seed));
    state.mode = 'title';
    state.timeLeft = TUNE.gameSec;
    state.boundary = 0.5;
    state.sleepDepth = 0.76;
    state.disturbance = 0;
    state.disturbanceTotal = 0;
    state.reclaim = TUNE.reclaimBase;
    state.twitch = 0.15;
    state.input = 'wait';
    state.score = null;
    state.titlePick = null;
    state.animTime = 0;
    state.floaty = [];
    prepareEvents();
    showTitleOverlay();
  }

  function startGame() {
    ensureAudio();
    state.mode = 'playing';
    state.timeLeft = TUNE.gameSec;
    state.boundary = 0.5;
    state.sleepDepth = 0.76;
    state.disturbance = 0;
    state.disturbanceTotal = 0;
    state.reclaim = TUNE.reclaimBase;
    state.twitch = 0.15;
    state.input = 'wait';
    state.score = null;
    state.titlePick = null;
    state.animTime = 0;
    state.floaty = [];
    prepareEvents();
    hideOverlay();
    beep('triangle', 420, 0.08, 0.035);
  }

  function endGame() {
    state.mode = 'result';
    const B = Math.round(state.boundary * 100);
    const Q = Math.round(clamp(100 - state.disturbanceTotal * TUNE.kDisturbanceToQ, 0, 100));
    const penalty = Q >= 75 ? 1 : Math.pow(Q / 75, TUNE.penaltyPow);
    const finalScore = Math.round(B * penalty);

    let tier = 'D';
    if (Q >= 85 && finalScore >= 82) tier = 'S';
    else if (Q >= 75 && finalScore >= 66) tier = 'A';
    else if (Q >= 60 && finalScore >= 48) tier = 'B';
    else if (Q >= 45 && finalScore >= 28) tier = 'C';

    const picks = TITLES.filter(t => t.tier === tier);
    const idx = Math.floor(mulberry32(hashStringToInt(`${seed}-${B}-${Q}-${finalScore}`))() * picks.length);
    const picked = picks[idx] || TITLES[0];

    state.score = { B, Q, finalScore, tier };
    state.titlePick = picked;
    showResultOverlay();
    beep('sine', 280, 0.2, 0.04);
  }

  function showEvent(ev) {
    eventBox.classList.remove('hidden');
    eventBox.innerHTML = `<div><strong>${ev.name}</strong></div><div class="small">${ev.hint}</div>`;
    state.eventDisplayTimer = TUNE.eventShowSec;
  }

  function applyEventEffect(ev, dt) {
    const e = ev.effects;
    state.reclaim = clamp(state.reclaim + e.reclaim * dt / ev.durSec, 0, 0.28);
    state.sleepDepth = clamp(state.sleepDepth + e.sleep * dt / ev.durSec, 0, 1);
    state.twitch = clamp(state.twitch + e.twitch * dt / ev.durSec, 0, 1);
    state.disturbance = clamp(state.disturbance + e.disturbance * dt / ev.durSec, 0, 3);
  }

  function updatePlaying(dt) {
    state.timeLeft -= dt;
    if (state.timeLeft <= 0) {
      state.timeLeft = 0;
      endGame();
      return;
    }

    const elapsed = TUNE.gameSec - state.timeLeft;
    const nextEv = state.eventTimeline[state.eventIndex];
    if (nextEv && elapsed >= nextEv.triggerAt) {
      state.activeEvent = { ...nextEv, left: nextEv.durSec };
      state.eventIndex++;
      showEvent(nextEv);
      beep('square', 180, 0.06, 0.02);
    }

    if (state.activeEvent) {
      applyEventEffect(state.activeEvent, dt);
      state.activeEvent.left -= dt;
      if (state.activeEvent.left <= 0) state.activeEvent = null;
    }

    if (state.eventDisplayTimer > 0) {
      state.eventDisplayTimer -= dt;
      if (state.eventDisplayTimer <= 0) eventBox.classList.add('hidden');
    }

    let boundaryDelta = 0;
    if (state.input === 'pull') {
      boundaryDelta += TUNE.pullBoundaryPerSec;
      const risk = 1 + state.twitch * 1.3;
      state.disturbance += TUNE.pullDisturbancePerSec * dt * risk;
      if (state.twitch > 0.72 && Math.random() < 0.06) spawnFloat('ãƒ”ã‚¯â€¦', '#ffd166');
    } else if (state.input === 'wait') {
      boundaryDelta -= TUNE.waitBoundaryDecayPerSec;
      state.sleepDepth += TUNE.waitSleepRecoverPerSec * dt * (1 - state.disturbance * 0.25);
      if (Math.random() < 0.012) spawnFloat('ã™ã…â€¦', '#bde0fe');
    } else if (state.input === 'return') {
      boundaryDelta -= TUNE.returnBoundaryPerSec;
      state.sleepDepth += TUNE.returnSleepRecoverPerSec * dt;
      state.disturbance -= 0.35 * dt;
      if (Math.random() < 0.02) spawnFloat('ã‚€ã«ã‚ƒâ€¦', '#caffbf');
    }

    const reclaimNow = state.reclaim + state.twitch * TUNE.reclaimTwitchBoost;
    boundaryDelta -= reclaimNow * dt;

    state.boundary = clamp(state.boundary + boundaryDelta * dt, 0.02, 0.98);

    state.disturbance = Math.max(0, state.disturbance - TUNE.disturbanceDecay * dt);
    state.sleepDepth = clamp(state.sleepDepth - state.disturbance * TUNE.disturbanceToSleepDrop * dt, 0, 1);
    state.disturbanceTotal += state.disturbance * dt;

    state.twitch = clamp(state.twitch + (0.35 - state.sleepDepth) * 0.38 * dt - 0.12 * dt, 0, 1);

    if (Math.random() < 0.008) {
      const f = state.sleepDepth > 0.55 ? 'ã™ã…â€¦' : 'â€¦';
      spawnFloat(f, state.sleepDepth > 0.55 ? '#ade8f4' : '#ffadad');
    }

    if (state.input === 'pull' && Math.random() < 0.014) beep('triangle', 220 + state.twitch*180, 0.03, 0.02);
  }

  function spawnFloat(text, color) {
    state.floaty.push({ text, color, x: 0.62 + rng()*0.25, y: 0.36 + rng()*0.2, life: 1.2 });
  }

  function updateFloaty(dt) {
    for (const f of state.floaty) {
      f.life -= dt;
      f.y -= dt * 0.08;
    }
    state.floaty = state.floaty.filter(f => f.life > 0);
  }

  function showTitleOverlay() {
    overlay.innerHTML = `<div class="card">
      <h1>ãµã¨ã‚“ç©ºæ°—èª­ã¿ãƒãƒˆãƒ«</h1>
      <p>20ç§’ã§ã€Œå¼•ã / å¾…ã¤ / æˆ»ã™ã€ã‚’ä½¿ã„åˆ†ã‘ã‚ˆã†ã€‚</p>
      <p>å–ã‚Šã™ãã‚‹ã¨ç›¸æ‰‹ã®ç¡çœ ã®è³ªãŒä¸‹ãŒã£ã¦ã€ç¿Œæœè©•ä¾¡ãŒè½ã¡ã¾ã™ã€‚</p>
      <p class="small">ãƒ’ãƒ³ãƒˆ: ãƒ”ã‚¯â€¦ï¼ˆå¯è¿”ã‚Šäºˆå…†ï¼‰ãŒå¼·ã„ã¨ãã®ã€Œå¼•ãã€ã¯å±é™ºï¼</p>
    </div>`;
  }
  function showResultOverlay() {
    const s = state.score, t = state.titlePick;
    overlay.innerHTML = `<div class="card">
      <h1>ç¿Œæœè©•ä¾¡: ${t.tier}ã€Œ${t.title}ã€</h1>
      <p>${t.line}</p>
      <p><strong>å æœ‰ç‡ B:</strong> ${s.B}% ï¼ <strong>ç¡çœ ã®è³ª Q:</strong> ${s.Q} ï¼ <strong>æœ€çµ‚:</strong> ${s.finalScore}</p>
      <p class="small">seed: ${seed}</p>
    </div>`;
  }
  function hideOverlay() { overlay.innerHTML = ''; }

  function drawScene() {
    const w = canvas.width / dpr;
    const h = canvas.height / dpr;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.scale(dpr, dpr);

    const bedX = w * 0.08;
    const bedY = h * 0.3;
    const bedW = w * 0.84;
    const bedH = h * 0.45;

    ctx.fillStyle = 'rgba(255,255,255,0.08)';
    roundRect(ctx, bedX, bedY, bedW, bedH, 20); ctx.fill();

    const split = bedX + bedW * state.boundary;
    ctx.fillStyle = 'rgba(255,209,102,0.35)';
    roundRect(ctx, bedX, bedY + 6, split - bedX, bedH - 12, 16); ctx.fill();
    ctx.fillStyle = 'rgba(173,232,244,0.22)';
    roundRect(ctx, split, bedY + 6, bedX + bedW - split, bedH - 12, 16); ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.5)';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(split, bedY + 10); ctx.lineTo(split, bedY + bedH - 10); ctx.stroke();

    const bob = Math.sin(state.animTime * 2.8) * 2;
    drawSleeper(bedX + bedW*0.27, bedY + bedH*0.53 + bob*0.5, '#ffb4a2', false);
    drawSleeper(bedX + bedW*0.73, bedY + bedH*0.53 - bob*0.4, '#bde0fe', true);

    // subtle hints
    const zStrength = state.sleepDepth;
    ctx.fillStyle = `rgba(255,255,255,${0.25 + zStrength*0.55})`;
    ctx.font = `${Math.round(13 + zStrength*12)}px sans-serif`;
    ctx.fillText('Zzz', bedX + bedW*0.76, bedY + bedH*0.25);
    if (state.twitch > 0.62) {
      ctx.fillStyle = `rgba(255,209,102,${0.35 + (state.twitch-0.62)})`;
      ctx.font = '16px sans-serif';
      ctx.fillText('ãƒ”ã‚¯â€¦', bedX + bedW*0.67, bedY + bedH*0.2);
    }

    for (const f of state.floaty) {
      ctx.globalAlpha = clamp(f.life,0,1);
      ctx.fillStyle = f.color;
      ctx.font = '14px sans-serif';
      ctx.fillText(f.text, bedX + bedW*f.x, bedY + bedH*f.y);
      ctx.globalAlpha = 1;
    }

    drawMiniReadouts(w, h);
    ctx.restore();
  }

  function drawMiniReadouts(w,h) {
    const x = w*0.08, y = h*0.82;
    const b = Math.round(state.boundary * 100);
    const qProxy = Math.round(clamp(100 - state.disturbanceTotal*TUNE.kDisturbanceToQ, 0, 100));
    ctx.fillStyle='rgba(0,0,0,0.35)';
    roundRect(ctx, x, y, w*0.84, h*0.12, 10); ctx.fill();
    ctx.fillStyle='rgba(255,255,255,0.9)';
    ctx.font='13px sans-serif';
    ctx.fillText(`å æœ‰ ${b}%`, x+12, y+20);
    ctx.fillText(`ç¡çœ ã®è³ª(æ¨å®š) ${qProxy}`, x+12, y+38);
    ctx.fillText(`ç©ºæ°—èª­ã¿: ${state.twitch>0.7?'è¦æ³¨æ„':state.twitch>0.45?'ãµã¤ã†':'å®‰å®š'}`, x+12, y+56);
  }

  function drawSleeper(x,y,color,flip=false) {
    ctx.save();
    ctx.translate(x,y);
    if (flip) ctx.scale(-1,1);
    ctx.fillStyle = color;
    ctx.beginPath(); ctx.ellipse(0,0,34,22,0,0,Math.PI*2); ctx.fill();
    ctx.fillStyle = '#ffe5d9';
    ctx.beginPath(); ctx.arc(-26,-2,10,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = 'rgba(0,0,0,0.38)';
    ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(-30,-1); ctx.lineTo(-24,-1); ctx.stroke();
    ctx.restore();
  }

  function roundRect(c,x,y,w,h,r){
    c.beginPath();
    c.moveTo(x+r,y);
    c.arcTo(x+w,y,x+w,y+h,r);
    c.arcTo(x+w,y+h,x,y+h,r);
    c.arcTo(x,y+h,x,y,r);
    c.arcTo(x,y,x+w,y,r);
    c.closePath();
  }

  // ===== Card export =====
  function saveResultCard() {
    if (!state.score || !state.titlePick) {
      alert('å…ˆã«1ãƒ—ãƒ¬ã‚¤ã—ã¦çµæœã‚’å‡ºã—ã¦ãã ã•ã„ã€‚');
      return;
    }
    const c = document.createElement('canvas');
    c.width = 1080; c.height = 1080;
    const g = c.getContext('2d');
    const grad = g.createLinearGradient(0,0,1080,1080);
    grad.addColorStop(0,'#1d3557'); grad.addColorStop(1,'#2a9d8f');
    g.fillStyle = grad; g.fillRect(0,0,1080,1080);
    g.fillStyle = 'rgba(255,255,255,0.12)';
    g.fillRect(80,120,920,760);
    g.fillStyle = '#fff';
    g.font = 'bold 66px sans-serif'; g.fillText('ãµã¨ã‚“ç©ºæ°—èª­ã¿ãƒãƒˆãƒ«', 120, 220);
    g.font = 'bold 76px sans-serif'; g.fillText(`ç¿Œæœè©•ä¾¡ ${state.titlePick.tier}`, 120, 330);
    g.font = 'bold 58px sans-serif'; g.fillText(`ã€Œ${state.titlePick.title}ã€`, 120, 420);
    g.font = '44px sans-serif'; g.fillText(state.titlePick.line, 120, 500);
    g.font = 'bold 64px sans-serif'; g.fillText(`å æœ‰ç‡ B: ${state.score.B}%`, 120, 620);
    g.fillText(`ç¡çœ ã®è³ª Q: ${state.score.Q}`, 120, 710);
    g.fillText(`Final: ${state.score.finalScore}`, 120, 800);
    g.font = '36px sans-serif'; g.fillText(`seed: ${seed}`, 120, 890);
    g.fillText('#ãµã¨ã‚“ç©ºæ°—èª­ã¿ #ãƒŸãƒ‹ã‚²ãƒ¼ãƒ ', 120, 960);

    c.toBlob(blob => {
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `futon_result_${seed}.png`;
      a.click();
      setTimeout(() => URL.revokeObjectURL(a.href), 1500);
    }, 'image/png');
  }

  function getShareUrl(withResult = false) {
    const u = new URL(location.href);
    u.searchParams.set('seed', seed);
    if (withResult && state.score && state.titlePick) {
      u.searchParams.set('b', state.score.B);
      u.searchParams.set('q', state.score.Q);
      u.searchParams.set('tier', state.titlePick.tier);
    }
    return u.toString();
  }

  async function copySeedUrl() {
    const text = getShareUrl(false);
    try {
      await navigator.clipboard.writeText(text);
      btnCopySeed.textContent = 'ã‚³ãƒ”ãƒ¼å®Œäº†';
      setTimeout(() => btnCopySeed.textContent = 'seed URLã‚³ãƒ”ãƒ¼', 900);
    } catch {
      prompt('ã“ã®URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„', text);
    }
  }

  function shareX() {
    const s = state.score;
    const summary = s
      ? `å æœ‰${s.B}% / ç¡çœ Q${s.Q} / ${state.titlePick.tier}ã€Œ${state.titlePick.title}ã€`
      : 'ç©ºæ°—ã‚’èª­ã¿ã¤ã¤å¸ƒå›£ã‚’å¼•ã20ç§’ã‚²ãƒ¼ãƒ ';
    const text = `ãµã¨ã‚“ç©ºæ°—èª­ã¿ãƒãƒˆãƒ«ğŸ›Œ\n${summary}\n#ãµã¨ã‚“ç©ºæ°—èª­ã¿ #ãƒŸãƒ‹ã‚²ãƒ¼ãƒ `;
    const intent = new URL('https://twitter.com/intent/tweet');
    intent.searchParams.set('text', text);
    intent.searchParams.set('url', getShareUrl(true));
    window.open(intent.toString(), '_blank', 'noopener,noreferrer');
  }

  // ===== input =====
  function bindActionButton(btn, action) {
    const onDown = (e) => {
      e.preventDefault();
      if (state.mode !== 'playing') return;
      ensureAudio();
      state.input = action;
      if (action === 'pull') beep('sawtooth', 250, 0.03, 0.022);
      if (action === 'return') beep('sine', 520, 0.04, 0.02);
    };
    const onUp = (e) => {
      e.preventDefault();
      if (state.mode === 'playing') state.input = 'wait';
    };
    btn.addEventListener('pointerdown', onDown, {passive:false});
    btn.addEventListener('pointerup', onUp, {passive:false});
    btn.addEventListener('pointercancel', onUp, {passive:false});
    btn.addEventListener('contextmenu', e => e.preventDefault());
  }
  bindActionButton(btnPull, 'pull');
  bindActionButton(btnWait, 'wait');
  bindActionButton(btnReturn, 'return');

  btnStart.addEventListener('click', () => startGame());
  btnRestart.addEventListener('click', () => resetRun());
  btnMute.addEventListener('click', () => {
    muted = !muted;
    btnMute.textContent = muted ? 'ğŸ”ˆ éŸ³OFF' : 'ğŸ”Š éŸ³ON';
    if (muted && audioCtx) audioCtx.suspend();
    else ensureAudio();
  });
  btnRandSeed.addEventListener('click', () => { setSeed(makeRandomSeed()); resetRun(); });
  btnToday.addEventListener('click', () => { setSeed(getTodaySeed()); resetRun(); });
  btnCopySeed.addEventListener('click', copySeedUrl);
  btnShareX.addEventListener('click', shareX);
  btnCard.addEventListener('click', saveResultCard);

  // stop accidental scroll/zoom
  const block = e => e.preventDefault();
  document.addEventListener('touchmove', block, {passive:false});
  document.addEventListener('gesturestart', block, {passive:false});

  // ===== loop =====
  let dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  function fitCanvas() {
    const r = canvas.getBoundingClientRect();
    dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    canvas.width = Math.floor(r.width * dpr);
    canvas.height = Math.floor(r.height * dpr);
  }
  addEventListener('resize', fitCanvas);
  fitCanvas();
  setSeed(seed);
  resetRun();

  let last = performance.now();
  function tick(now) {
    let dt = (now - last) / 1000;
    last = now;
    dt = Math.min(dt, TUNE.dtMax);
    state.animTime += dt;

    if (state.mode === 'playing') updatePlaying(dt);
    updateFloaty(dt);

    timeLabel.textContent = `${state.timeLeft.toFixed(1)}s`;
    statusLabel.textContent = state.mode;

    drawScene();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
